# 阴影贴图

## **概述**

着色的过程是一种局部的现象，只需要考虑着色点自己，光源，以及摄像机，不会考虑其他物体，甚至不考虑物体自身的其他部分对着色点的影响。

但是，着色点之间是会有遮挡的关系的，是会有阴影的。

阴影的问题是在光栅化的范围里解决的。

本质上 Shadow Mapping 这个方法是一种图像空间的做法，也就是在生成阴影这一步，不需要知道场景的几何信息。

这个方法的关键思想在于：
- 如果有点不在阴影里，那么这个点可以被摄像机和光源都看到。

从这个思想我们看出阴影应该会有很明显的边界，也就是硬阴影

同时这个方法也会产生走样问题，并且经典的 Shadow Mapping 只能处理点光源


## **阴影贴图原理**

首先我们从光源看向场景做一遍光栅化（以光源视角渲染场景），不进行着色，只记录这个场景的深度值，作为阴影贴图

![](https://img-blog.csdnimg.cn/2020082116010534.png)

从摄像机出发，再次看向这个场景，把现在看到的点，投影回光源刚才看到的投影平面上，然后分别取得点在当前视角的深度值和投影到光源视角的深度值，对这两个深度值比较：
- 如果当前视角的深度值更小，只渲染光照。
- 如果当前视角的深度值更大，需要渲染阴影。

![](https://img-blog.csdnimg.cn/2020082116102580.png)

阴影贴图存在的问题

- 使用点光源时只能生成有很明显的边界的 **硬阴影**
- 浮点数的相等比较存在精度问题
- 阴影贴图本身存在分辨率，它与渲染时的分辨率的搭配不好的话，会存在走样，更大的深度图的分辨率，开销也会变大

所以从光栅化的思想去做全局的现象，是比较困难的事情

即使存在问题，依然是目前的主流方法

## OpenGL 实现

在深度测试的章节中，我们知道，深度缓冲指的是，在 OpenGL 在光栅化阶段为以摄像机视角所渲染的场景的片段生成的一系列区间为 [0,1] 的深度值。

由此，可以利用 OpenGL 这一特性，以同样的方式，**生成以光源视角所渲染场景所得到的深度缓冲**，将之作为阴影贴图。

具体实现逻辑如下：
- 初始化阶段：
    - 分别为渲染场景和生成阴影贴图准备两个 shader
    - 设置场景的顶点数据
    - 设置一个 framebuffer，并将阴影贴图对象附加到这个 framebuffer。
    - 确定光源位置：
        - 如果是点光源或聚光光源，直接使用光源位置
        - 如果是平行光，则在光照方向上选取一个位置作为假定的光源位置
    - 设置光照贴图和阴影贴图的纹理单元 ID
- 渲染阶段：
    - clear & clear buffer bit
    - 准备光源的 VP 矩阵（平行光采用正射投影），设置到shader中准备进行绘制时，把世界坐标变换为光源视角下的场景坐标
    - 在 framebuffer 中渲染光源视角下的场景，但只记录坐标（顶点着色器），不进行着色（片段着色器），OpenGL 会自动为该场景生成深度缓冲，得到了深度贴图。
    - 结合阴影贴图渲染摄像机视角下的场景：
        - 渲染场景的同时，需要使用光源的 VP 矩阵将摄像机视角下的场景坐标转换为光源视角下的场景坐标。
        - 用光源视角下的场景坐标从阴影贴图中采样深度值，然后和摄像机视角下的场景坐标的深度值作比较，判断是否渲染阴影。


